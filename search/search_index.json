{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"programming/code-review/","title":"Best Practices for Peer Code Review","text":"<p>Original article from Cisco : BestPracticesForPeerCodeReview.pdf</p>"},{"location":"programming/code-review/#summary-of-the-article","title":"Summary of the article","text":""},{"location":"programming/code-review/#1-review-fewer-than-200-400-lines-of-code-at-a-time-within-60-90min-70-90-defect","title":"1. \"Review fewer than 200-400 lines of code at a time within 60-90min, 70-90% defect\"","text":"<p>--&gt; Don't review too much at the same time</p>"},{"location":"programming/code-review/#2-aim-for-an-inspection-rate-of-less-than-300-500-lochour-6-8-locmn","title":"2. \"Aim for an inspection rate of less than 300-500 LOC/hour** (6-8 LOC/mn!)\"","text":"<p>--&gt; Don't review too quickly</p>"},{"location":"programming/code-review/#3-take-enough-time-for-a-proper-slow-review-but-not-more-than-60-90-minutes","title":"3. \"Take enough time for a proper, slow review, but not more than 60-90 minutes\"","text":"<p>--&gt; Don't spend too much time</p>"},{"location":"programming/code-review/#4-authors-should-annotate-source-code-before-the-review-begins","title":"4. Authors should annotate source code before the review begins","text":"<p>--&gt; Describe your dev</p> <ul> <li>Authors might be able to eliminate most defects themselves. They should \"prepare\" the CR by annotating code. These comments are not code comments but comments for reviewers.</li> <li>By doing so, they find themselves potential bugs in their devs.</li> <li>Potential explanation of why fewer bugs: where there are comments, the reviewers is \"biased\" and see less bugs (because his spirit has been anchored to the developer interpretation). But after investigation, this is not the case.</li> </ul>"},{"location":"programming/code-review/#5-establish-quantifiable-goals-for-code-review-and-capture-metrics-so-you-can-improve-your-processes","title":"5. Establish quantifiable goals for code review and capture metrics so you can improve your processes","text":"<p>--&gt; Measure the impact of the CR</p>"},{"location":"programming/code-review/#6-checklists-substantially-improve-results-for-both-authors-and-reviewers","title":"6. Checklists substantially improve results for both authors and reviewers","text":""},{"location":"programming/code-review/#7-verify-that-defects-are-actually-fixed","title":"7. Verify that defects are actually fixed!","text":""},{"location":"programming/code-review/#8-managers-must-foster-a-good-code-review-culture-in-which-finding-defects-is-viewed-positively","title":"8. Managers must foster a good code review culture in which finding defects is viewed positively","text":"<ul> <li>Easy to see defects negatively (mistakes in the code), but it should be seen as a positive mean for learning, growing and communication.</li> <li>It's not an accusation way of working: the author mades the bugs and the reviewer saw it, but more as en efficient pair-programming session.</li> <li>To maintain a consistent message that finding bugs is good, management must promise that defect densities will never be used in performance reports</li> </ul>"},{"location":"programming/code-review/#9-beware-the-big-brother-effect","title":"9. Beware the \u201cBig Brother\u201d effect","text":""},{"location":"programming/code-review/#10-the-ego-effect-do-at-least-some-code-review-even-if-you-dont-have-time-to-review-it-all","title":"10. The Ego Effect: Do at least some code review, even if you don\u2019t have time to review it all","text":"<p>The Ego Effect: knowing that your code will be reviewed makes you more conscientious before pushing your work. This effect is also the case even if the review is not compulsory: reviewing 20-30% of the code would probably be optimal to assure the Ego Effect with minimal time expenditure.</p>"},{"location":"programming/code-review/#11-lightweight-style-code-reviews-are-efficient-practical-and-effective-at-finding-bugs","title":"11. Lightweight-style code reviews are efficient, practical, and effective at finding bugs","text":"<pre><code>--&gt; GitHub is pretty nice!\n</code></pre>"},{"location":"programming/cryptography/","title":"PGP, OpenPGP, GPG","text":""},{"location":"programming/cryptography/#pgp-pretty-good-privacy","title":"PGP: \"Pretty Good Privacy\"","text":"<p>Private software, originally created by PGP Inc. Use several methods to allow encryption of data (hash, data compression, symmetric cryptography, public key cryptography)</p>"},{"location":"programming/cryptography/#openpgp","title":"OpenPGP","text":"<p>Phil Zimmerman, which worked at PGP Inc., wanted to security and cryptography for privacy to be free. So he created OpenPGP, an open source norm for PGP.</p>"},{"location":"programming/cryptography/#gpg-gnu-privacy-guard","title":"GPG: GNU Privacy Guard","text":"<p>GPG is the implementation by GNU.</p>"},{"location":"programming/docker/","title":"Docker","text":""},{"location":"programming/docker/#update-all-images","title":"Update all images","text":"<pre><code>di --format \"{{.Repository}}:{{.Tag}}\" | xargs -L1 docker pull\n</code></pre>"},{"location":"programming/efcore/","title":"Entity Framework Core","text":"<p>Entity Framework Core is an ORM (Object Relational Mapper), which is a library helping developer to handle links to database. It handles automatic mapping between database tables (relational) and \"Plain Old CLR Objects\" (POCO, POJO in Java, etc.).</p>"},{"location":"programming/efcore/#entity-framework-core-in-action","title":"Entity Framework Core in Action","text":"<p>Book written by Jon Smith</p>"},{"location":"programming/efcore/#chapter-2-querying-database","title":"Chapter 2: Querying database","text":"<p>Objects to create:</p> <ul> <li>Entity Models: C# objects mapped to the database scheme, which will represent tables</li> <li><code>DBContext</code>: configuring database (connection string, perf, etc.) + declaring the Entity Models</li> <li>DTO objects (for \"Data Transfering Object\"): objects aiming at containing data for transferring it between 2 parts of the library</li> <li>a function <code>IQueryable&lt;BookDto&gt; MapBookToDto(IQueryable&lt;Book&gt;)</code> which will transform the SQL Query into a DTO object for presentation</li> <li>sorting, filtering, paging functions: <code>IQueryable&lt;BookDto&gt; Filtering(IQueryable&lt;BookDto&gt;, FilteringOptions)</code></li> </ul> <p>Layered Architecture: for small-to-medium sized projects:</p> <ul> <li>a DataLayer: <code>DBContext</code> + Entity Models. Has no knowledge of any other layer</li> <li>a ServiceLayer: implementing the <code>MapBookToDto</code> function + filtering, sorting, paging functions</li> <li>a PresentationLayer (e.g. ASP.Net Core): calling the functions defined in the ServiceLayer and send the DTO objects to the views (e.g. HTML pages)</li> </ul>"},{"location":"programming/kubernetes/","title":"Basics","text":"<p>Notions:</p> <ul> <li>Pod: smallest unit in Kubernetes. A pod can be a set of several containers. For instance an app Node.js + a database PostgreSQL with it.</li> <li>Node: a Node is a worker machine, it can be a physical or virtual machine, on which there will be several Pods. A Node has at least:<ul> <li>a Docker runtime (to pull images, run the containers inside the pods, etc.)</li> <li>a Kubelet, which is the process allowing to communicate with the Master Node</li> </ul> </li> <li>Deployment:</li> <li>Service: abstraction which defines a logical set of Pods and a policy by which to access them. Pods can die, and can be replaced, but we need something to store the identification of each one (for instance IPs)</li> </ul>"},{"location":"programming/kubernetes/#main-commands","title":"Main commands","text":"<ul> <li><code>kubectl get</code>: list resources</li> <li><code>kubectl describe</code>: show detailed information about a resource</li> <li><code>kubectl logs</code>: print the logs from a container in a pod</li> <li><code>kubectl exec</code>: execute a command on a container in a pod</li> </ul> <p>Pods are mortal. They have a lifecycle.</p>"},{"location":"programming/kubernetes/#minikube","title":"Minikube","text":"<p>Minikube is a tool used to test Kubernetes. It creates a Kubernetes cluster with only one Nod, inside a Virtual Machine. Some useful commands are available with it:</p> <p><code>minikube service &lt;service-name&gt;</code></p> <p><code>minikube dashboard</code> --&gt; extremely useful. Open a Dashboard to have an overlook of the cluster (only one node because of Minikube but still cool).</p> <p>Minikube with hyperkit</p>"},{"location":"programming/kubernetes/#how-to-interact-with-kubernetes","title":"How to interact with Kubernetes","text":"<p>They are three ways to interact with Kubernetes:</p> <ul> <li>Imperative commmands</li> <li>Imperative object configuration</li> <li>Declarative object configuration</li> </ul>"},{"location":"programming/linux/","title":"Linux","text":""},{"location":"programming/linux/#monitoring-temperature-on-linux","title":"Monitoring temperature on Linux","text":"<p>Monitoring CPU and GPU Temperatures on Linux</p> <p>From a Unix &amp; Linux Stack Exchange question:</p> <ul> <li>Nagios: seems to be the best choice (standard)</li> <li>Munin</li> <li>Installation (Digital Ocean)</li> <li>Cacti</li> <li>Monitorix</li> </ul>"},{"location":"programming/linux/#solve-eternal-locales-problems","title":"Solve (eternal) locales problems","text":"<p>To solve locales problems (LC_ALL, LC_CTYPE, ...), simply comment the following line in <code>/etc/ssh/sshd_config</code>: <pre><code>AcceptEnv LC_*\n</code></pre></p>"},{"location":"programming/linux/#ssh-agent-forwarding","title":"SSH Agent Forwarding","text":""},{"location":"programming/linux/#from-a-user-to-root-doing-sudo","title":"From a user to root (doing sudo)","text":"<p>The goal is to tell <code>sudo</code> to transfer the environment variable <code>SSH_AUTH_SOCK</code> to root. For that, open the /etc/sudoers file</p> <p>[StackOverflow source]</p>"},{"location":"programming/cpp/effective-modern-cpp/","title":"Effective modern cpp","text":""},{"location":"programming/cpp/effective-modern-cpp/#chapter-4-smart-pointers","title":"Chapter 4: Smart Pointers","text":"<p>Raw pointers are genuinely bad</p> <ul> <li>points to single object or array? </li> <li>should you destroy what it points to, i.e. does the pointer owns the object?</li> <li>if yes, how? <code>delete</code>, <code>delete[]</code>? </li> <li>if yes, hard to do it only exactly once along every path in the code (memory leak or undefined behavior if destroyed twice)</li> <li>no way to tell if the pointer dangles</li> </ul> <p>Smarts pointers are the way to solve it. </p> <p>you should therefore prefer smart pointers to raw pointers</p> <p>4 smart pointers in C++11: - <code>std::auto_ptr</code>: tried to model unique ownership, but without move semantic. Full of bugs -&gt; NEVER use, use <code>std::unique_ptr</code> instead - <code>std::unique_ptr</code> - <code>std::shared_ptr</code> - <code>std::weak_ptr</code></p>"},{"location":"programming/cpp/effective-modern-cpp/#18-use-stdunique_ptr-for-exclusive-ownership-resource-management","title":"18. Use <code>std::unique_ptr</code> for exclusive-ownership resource management","text":"<p>Small and fast.</p> <p>*If a raw pointer is small enough and fast enough for you, a <code>std::unique_ptr</code> almost certainly is, too. *</p> <p>[!TIP] Summary By default, resource destruction takes place via <code>delete</code> but custom deleters can be specified. Stateful deleters increase the size of <code>std::unique_ptr</code> objects.</p> <p><code>std::unique_ptr -&gt; std::shared_ptr</code> conversion is easy.</p>"},{"location":"programming/cpp/effective-modern-cpp/#19-use-stdshared_ptr-for-shared-ownership-resource-management","title":"19. Use <code>std::shared_ptr</code> for shared-ownership resource management.","text":"<p>Garbage collection vs destructors : \"Resource lifetime management should be done by machines\".</p> <p>But the timing of resource reclamation can be nondeterministic, whereas destructors calls are.</p> <p><code>std::shared_ptr</code> is the C++11 way of having the best of both worlds: automatically but predictable timing.</p> <p>All <code>std::shared_ptr</code> pointing to the same object have a reference count keeping track of how many they are. When the count reaches 0, the memory is deallocated.</p> <ul> <li> <p><code>std::shared_ptr</code> are 2x the size of a raw pointer, because they also contain a raw pointer to the resource's reference count.</p> </li> <li> <p>Memory for the reference count must be dynamically allocated. Pointed-to object knows nothing about the reference count, so have no space to store it. When using <code>std::make_shared</code>, the cost of allocation is avoided.</p> </li> <li> <p>Increments and decrements of the reference counts must be atomic, because there can be simultaneous readers/writers in different threads.</p> </li> </ul>"},{"location":"programming/cpp/effective-cpp/chapter-1/","title":"Accustoming Yourself to C++","text":""},{"location":"programming/cpp/effective-cpp/chapter-1/#item-1-view-c-as-a-federation-of-languages","title":"Item 1: View C++ as a federation of languages","text":""},{"location":"programming/cpp/effective-cpp/chapter-1/#item-2-prefer-consts-enums-and-inlines-to-defines","title":"Item 2: Prefer <code>const</code>s, <code>enum</code>s and <code>inline</code>s to <code>#define</code>s","text":"<p>Or \"prefer the compiler to the preprocessor\".</p> <p>Instead of:</p> <pre><code>#define ASPECT_RATIO 1.653\n</code></pre> <p>prefer:</p> <pre><code>const double AspectRatio = 1.653; // uppercase names usually for macros\n</code></pre> <ul> <li>in the case of floating point constant, can yield smaller code, because the preprocessor will result in multiple copy</li> </ul>"},{"location":"programming/cpp/effective-cpp/chapter-1/#item-3-use-const-whenever-possible","title":"Item 3: Use <code>const</code> whenever possible","text":"<p>STL iterators are modeled on pointers so an <code>iterator</code> acts much like a <code>T*</code> pointer. Declaring an <code>iterator const</code> is like declaring a pointer <code>const</code> (i.e. declaring a <code>T * const</code>): the iterator isn't allowed to point to something different, but the pointed thing can be modified. To have an iterator to point to something that can't be modified, i.e. the STL analogue of a <code>const T*</code> pointer, you want a <code>const_iterator</code>.</p> <pre><code>std::vector&lt;int&gt; vec;\nconst std::vector&lt;int&gt;::iterator iter = vec.begin(); // iter acts like a `T* const`\n*iter = 10;    // OK, changes what `iter` points to\n++iter;        // error! `iter` is `const`\nstd::vector&lt;int&gt;::const_iterator citer = vec.begin(); // citer acts like a `const T*`\n*citer = 10;   // error! `citer` is `const`\n++citer;       // fine, changes `citer`\n</code></pre>"},{"location":"programming/cpp/effective-cpp/chapter-1/#const-in-return-value","title":"<code>const</code> in return value","text":"<p>Generally inappropriate, but can sometimes reduce the incidence of client errors without giving up safety or efficiency.</p> <pre><code>class Rational { ... };\nconst Rational operator*(const Rational &amp;lhs, const Rationale &amp;rhs);\nRational a, b, c;\n(a * b) = c;  // oops, meant to do a comparison... but doesn't compile!\n</code></pre>"},{"location":"programming/cpp/effective-cpp/chapter-1/#bitwise-constness-versus-logical-constness","title":"Bitwise <code>const</code>ness versus logical <code>const</code>ness","text":"<p>bitwise <code>const</code> means that not bit of the objects change. But the object can have pointer members whose the pointed objects can change! Therefore the behavior of this object will change. A most useful property is \"logical <code>const</code>ness\".</p> <p>C++ <code>const</code> can only check for bitwise <code>const</code>ness. Thanks to the <code>mutable</code> qualifier, members can be changed but still the object won't change its logical <code>const</code>ness.</p>"},{"location":"programming/cpp/effective-cpp/chapter-1/#item-4-make-sure-objects-are-initialized-before-theyre-used","title":"Item 4: make sure objects are initialized before they're used","text":"<ul> <li>use member initialization</li> </ul> <p>Summary</p> <ul> <li>Manually initialize objects of built-in type, because C++ only sometimes initializes them itself</li> <li>In a constructor, prefer member initialization list to assignment inside the body. List data members in the same order they're declared in the class</li> <li>Avoid initialization order problems across translation units by replacing non-local <code>static</code> objects with local <code>static</code> objects</li> </ul>"},{"location":"programming/cpp/effective-cpp/chapter-2/","title":"Constructors, Destructors and Assignment Operators","text":""},{"location":"programming/cpp/effective-cpp/chapter-2/#item-6-know-what-functions-c-silently-writes-and-calls","title":"Item 6: Know what functions C++ silently writes and calls.","text":""},{"location":"programming/cpp/effective-cpp/chapter-3/","title":"Resource Management","text":"<p>A resource is something that, once you're done using it, you need to return to the system.</p>"},{"location":"programming/cpp/effective-cpp/chapter-3/#item-13-use-objects-to-manage-resources","title":"Item 13: Use objects to manage resources","text":"<p>2 critical aspects of using objects to manage resources:</p> <ul> <li> <p>Resources are acquired and immediately turned over to resource-managing objects</p> <p>--&gt; \"Resource Acquisition Is Initialization\" (RAII)</p> </li> <li> <p>Resource-managing objects use their destructors to ensure that resources are released</p> </li> </ul> <p>Smart pointers are doing that for us, e.g; <code>std::auto_ptr</code>.</p> <p>Ex:</p> <p>Instead of</p> <pre><code>void f()\n{\nInvestment *pInv = createInvestment();\n...\ndelete pInv;\n}\n</code></pre> <p>prefer</p> <pre><code>void f()\n{\nstd::auto_ptr&lt;Investment&gt; pInv(createInvestment());\n}\n</code></pre> <p>But because an <code>std::auto_ptr</code> automatically <code>delete</code>s what it points to when it is destroyed, it's important that there never be more than one <code>auto_ptr</code> pointing to an object. For this reason, copying an <code>std::auto_ptr</code> (via copy constructor or copy assignment operator) sets the internal pointer to null and transfers the sole ownership to the copied object.</p> <p>This odd copying behavior means that they aren't the best way to manage all dynamically allocated resources.</p> <p>Summary</p> <ul> <li>To prevent resource leak, use RAII objects that acquire resources in their constructors and release them in their destructors</li> <li>Two commonly useful RAII classes are <code>shared_ptr</code> and <code>std::auto_ptr</code>. The first one is usually the best choice, because its behavior when copied is intuitive, whereas copying an <code>auto_ptr</code> sets it to null.</li> </ul>"},{"location":"programming/cpp/effective-cpp/chapter-3/#item-14-think-carefully-about-coyping-behavior-in-resource-managing-classes","title":"Item 14: THink carefully about coyping behavior in resource-managing classes","text":"<p>When creating a resource-allocating object, <code>shared_ptr</code> or <code>std::auto_ptr</code> make no sense to be used.</p> <p>Example for a <code>Lock</code> object:</p> <pre><code>class Lock {\npublic:\nexplicit Lock( Mutex *pm ) : mutexPtr( pm )\n{\nlock( mutexPtr );\n}\n~Lock()\n{\nunlock( mutexPtr );\n}\nprivate:\nMutex *mutexPtr;\n};\nvoid main()\n{\nMutex m;\n...\n{                 // create block to define critical section\nLock ml(&amp;m);  // lock the mutex\n...           // perform critical section operations\n}                 // automatically unlock mutex\n}\n</code></pre> <p>But what should happen if a <code>Lock</code> object is copied?</p> <pre><code>Lock ml1( &amp;m );\nLock m2( ml1 );\n</code></pre> <p>General question: what to do when a RAII object is copied? Often, several strategies:</p> <ul> <li> <p>prohibit copying</p> </li> <li> <p>reference count the underlying resource: in this case, it makes sense to make use of a <code>shared_ptr</code> inside the class, instead of a raw pointer. But, by default, when the reference count goes to 0 the <code>shared_ptr</code> will <code>delete</code> the resource, which is not what we want here. Fortunately we can pass a \"deleter\" to a <code>shared_ptr</code>, a function which will be called when reference count goes to 0.</p> <pre><code>class Lock {\npublic:\nexplicit Lock( Mutex *pm ) : mutexPtr( pm, unlock )\n{\nlock( mutexPtr.get() );\n}\nprivate:\nshared_ptr&lt; Mutex &gt; mutexPtr;\n}\n</code></pre> </li> <li> <p>Copy the underlying resource: also called \"deep copy\". Example: <code>std::string</code>.</p> </li> <li> <p>Transfer ownership of the underlying resource. This is the meaning of <code>std::auto_ptr</code>.</p> </li> </ul> <p>Summary</p> <ul> <li>Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.</li> </ul>"},{"location":"programming/cpp/effective-cpp/chapter-3/#item-15-provide-access-to-raw-resources-in-resource-managing-classes","title":"Item 15: Provide access to raw resources in resource-managing classes","text":"<p>You have the choice between explicit conversion or implicit conversion.</p> <p>First one is usually implemented via a <code>.get()</code> operator. Second one can be implemented by overriding the <code>operator HandleName() const</code>. The downside of implicit conversion is that it increases the chance of errors, e.g. a client can create a RAII object where he wanted a raw ressource object.</p>"},{"location":"programming/cpp/effective-cpp/chapter-3/#item-16-use-the-same-form-in-corresponding-uses-of-new-and-delete","title":"Item 16: Use the same form in corresponding uses of <code>new</code> and <code>delete</code>","text":""},{"location":"programming/cpp/effective-cpp/chapter-3/#item-17-store-newed-objects-in-smart-pointers-in-standalone-statements","title":"Item 17: Store <code>new</code>ed objects in smart pointers in standalone statements","text":"<p>Suppose the following function:</p> <pre><code>int priority();\nvoid processWidget(std::shared_ptr&lt; Widget &gt; pw, int priority);\n</code></pre> <p>If there is no implicit conversion from <code>Widget*</code> to <code>std::shared_ptr&lt;Widget&gt;</code> (which is fine), it is tempting to call it like that:</p> <pre><code>processWidget( std::shared_ptr&lt; Widget &gt;(new Widget), priority());\n</code></pre> <p>This can lead to memory leak: indeed we do not in which order the 3 following calls:</p> <ol> <li><code>new Widget</code></li> <li><code>std::shared_ptr</code> constructor</li> <li><code>priority()</code> will be done (we only now that 2. will be after 1. of course).</li> </ol> <p>Therefore, if the order is 1. -&gt; 3. -&gt; 2. and 3. raises an exception, the <code>Widget*</code> pointer will never be passed to the smart pointer, and therefore never be <code>delete</code>d.</p> <p>Use the following</p> <pre><code>std::shared_ptr&lt;Widget&gt; pW( new Widget );\nprocessWidget( pw, priority() );\n</code></pre>"},{"location":"programming/cpp/effective-cpp/chapter-4/","title":"Designs and Declarations","text":"<p>How to design and declare good C++ interfaces?</p>"},{"location":"programming/cpp/effective-cpp/chapter-4/#item-18-make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly","title":"Item 18: Make interfaces easy to use correctly and hard to use incorrectly","text":"<p>Assuming you're dealing with reasonable people, the clients are trying to do a good job. They want to use the interfaces correctly. That being the case, if they use one incorrectly, your interface is at least partially to blame. Ideally if an attempted use of an interface won't do what the client expects, the code won't compile; and if the code does compile it will do what the client wants.</p> <pre><code>class Date {\npublic:\nDate( int month, int day, int year);\n...\n};\n</code></pre> <p>May seen reasonable (at least in the USA..) but can pass <code>int</code> in wrong order, or use a month greater than 12.</p> <pre><code>class Date\n{\npublic:\nDate( const Month&amp; m const Day&amp; d, const Year&amp; y);\n};\n</code></pre> <p>Other way: restrict what can be done with a type --&gt; adding <code>const</code> (see item 3). More generally -&gt; have your types behave consistently with the built-in types, unless there's a good reason not to. Clients already know how types like <code>int</code> behave, so you should strive to have your types behave the same way.</p> <p>--&gt; the main characteristic leading to interfaces which are easy to use is consistency.</p> <p>Interfaces of STL are largely consistent, this helps make them easy to use (e.g. the method <code>size()</code> available on all containers).</p> <p>Other example:</p> <pre><code>Investment* createInvestment();\n</code></pre> <p>can leads to the user to not handle correctly the memory. He can uses a smart pointer, but nothing prevents him not to. A better idea would be:</p> <pre><code>std::shared_ptr&lt;Investment&gt; createInvestment();\n</code></pre> <p>Success</p> <ul> <li>Good interfaces are easy to use correctly and hard to use incorrectly.</li> <li>Ways to facilitate correct use include consistency in interfaces and behavioral compatibility with built-in types.</li> <li>Ways to prevent errors include creating new types, restricting operations on types, constraining object values and eliminating client resources management responsibilities.</li> <li><code>std::shared_ptr</code> supports custom <code>delete</code>rs. This prevents the cross-DLL problem (see item 14).</li> </ul>"},{"location":"programming/cpp/effective-cpp/chapter-4/#item-19-treat-class-deisgn-as-type-design","title":"Item 19: Treat class deisgn as type design.","text":""},{"location":"programming/cpp/effective-cpp/chapter-4/#item-20-prefer-pass-by-reference-to-const-to-pass-by-value","title":"Item 20: Prefer pass-by-reference-to-<code>const</code> to pass-by-value.","text":"<p>References are implemented as pointers. Therefore, for built-in types as <code>int</code> it makes sense to pass by value. Therefore, it could make sense to pass \"small\" custom types by value instead of by references. But even with small ones, there can be problems. Some compilers don't handle them the same way as built-in types. For instance, even if your custom type is based on <code>int</code>, some compiler won't allow to put them in registers. References being implemented as pointers, therefore as <code>int</code>, they will be put in registers.</p> <p>Furthermore, it avoids slicing problem: if you pass a derived class to a function which expects a base class, a copy will be created by a copy only of the \"base\" part of the class, leaving us with a real base class instance, which is almost never what we really want. Using reference makes it act polymorphically.</p> <p>Success</p> <ul> <li>Good interfaces are easy to use correctly and hard to use incorrectly.</li> </ul>"},{"location":"programming/cpp/effective-cpp/chapter-4/#item-21-dont-try-to-return-a-reference-when-you-must-return-an-object","title":"Item 21: Don't try to return a reference when you must return an object.","text":""},{"location":"programming/cpp/effective-cpp/chapter-4/#item-22-declare-data-members-private","title":"Item 22: Declare data members <code>private</code>","text":"<p>--&gt; data member shouldn't be <code>public</code> --&gt; all the arguments against <code>public</code> data members apply equally to <code>protected</code> ones.</p>"},{"location":"programming/python/async/","title":"Concurrent programming","text":"<p>Python allows concurrent programming thanks to the built-in library <code>asyncio</code>.</p>"},{"location":"programming/python/async/#since-python-37-asynciorun","title":"Since Python 3.7: <code>asyncio.run</code>","text":"<p><code>asyncio.run</code> is the preferred (simplest) way to launch an asynchronous program (it should be launched from the highest-end point, like the <code>main.py</code> probably). The best way to understand how <code>asyncio.run</code> interacts with its counterparts (<code>EventLoop.run_until_complete</code>, <code>run_forever</code>, etc.) is to see what is does. From this gist it can be seen that <code>asyncio.run</code> does the following:</p> <ul> <li>create a new event loop</li> <li>set the newly-created event loop as the current event loop</li> <li>run the coroutine util completed</li> <li>set the current event loop as None</li> </ul> <p>In Python code, it gives:</p> <pre><code>new_loop = asyncio.new_event_loop()\nasyncio.set_event_loop(new_loop)\nnew_loop.run_until_complete(coro)\nasyncio.set_event_loop(None)\nloop.close()\n</code></pre>"},{"location":"programming/python/gil/","title":"GIL in Python","text":"<p>Resources:</p> <ul> <li>Blog article on realpython.org </li> <li>Talk by Larry Hastings during PyCon 2015: Python's Infamous GIL (referenced by the former)</li> </ul> <p>Summary:</p> <ul> <li>There is no Garbage Collector in Python, so we need to count the references of any object, so that when this count reaches 0 we can free the memory allocated to store this object.</li> <li>Problem is: when several threads involved, they can all have different references to the same object --&gt; difficult to keep track of the references</li> <li>Solution taken for Python: simply disallowing it! There is a lock on the Python interpreter itself. If there are several threads involved, and if they want to execute native Python code, they have to wait for their turn to execute the Python interpreter.</li> <li>Dates:</li> <li>1990: Python invented</li> <li>1992: GIL added. At this time, there was no multi-core, because if you wanted to do it, you really had to physically handle 2 processors on the motherboard (so have a motherboard specially adapted for that).</li> <li>But now, the world is fully multi-core, since we managed to have several physical cores on the same processor</li> <li>Guido is aware of that, but he said he is ok to remove the GIL, only if it doesn't decrease performance on single-threaded examples --&gt; very difficult to reach!</li> </ul> <p>There have been attempts to do multi-threading on Python in Python 1.4 without any API change. They took all the global variables and turn them into <code>struct</code>s (structures).  The problem was of course of the references counting (as explained before). To solve this problem, they tried to create a resource which was keeping track of the counts of all references, but they had obviously to add a lock on this resource! To sum up: in order to remove the lock on the Python interpreter, they had to add a lock on the references counter, so that this resource could count the references efficiently in spite of the different threads running the Python interpreter simultaneously. But all the threads were constantly grabbing and releasing the lock so much, that the lock itself was causing a big performance issue --&gt; between 4x and 7x slower!</p> <p>In order to manage the memory, another possibility than the GIL (having a counter keeping track of the number of references there are of all the objects) would be to have a \"Pure\" Garbage Collector. It works the following way: when the memory is full (at least, almost full, because if we wait to have the absolute fullness of the memory, therefore it must certainly be that we cannot do any further computation to release it, given that any computation would require at least some memory..), then we stop all the program computation, and we do an exploration of all the objects currently used in the Program. All the objects which cannot be \"reached\" by the exploration cannot be used, and can be \"collected\" (a nice word to say destroyed and removed). </p> <p>CPython is not the only implementation of Python interpretation. There are four main ones, which does not all have a GIL, but have a GC:</p> Pure GC GIL cpython (C) no yes jython (java) yes no ironpython (C#) yes no pypy yes no* <p>It's perfectly possible to have a working Python interpreter without any sort of GIL. Would it be possible to have GC instead of reference counting? Yes. Would it be as fast as reference counting? We can't know until we do it. Conventional wisdom about GC is that it is about the same speed as reference counting. But the real problem is that it would break all the C extensions API, and we can't afford that (Python 3 did that, and it seems that it is slowly adapted.. not sure though).</p>"},{"location":"programming/python/packaging/","title":"Packaging","text":"<p>\u00c9tat de l'art du packaging python</p>"},{"location":"programming/python/pep/","title":"PEP","text":""},{"location":"programming/python/pep/#important-peps-to-remember","title":"Important PEPs to remember","text":""},{"location":"programming/python/pep/#generators-and-synchronicity","title":"Generators and synchronicity","text":"<ul> <li> <p>PEP 342 -- Coroutines via Enhanced Generators (10 May 2005, Python 2.5)     In particular, this solves:</p> <ul> <li>PEP 288 (2002): Generators Attributes and Exceptions (withdrawn)</li> <li>PEP 325 (25/08/2003): Resource-Release Support for Generators (rejected)</li> </ul> </li> <li> <p>PEP 380 -- Syntax for Delegating to a Subgenerator (13 Feb 2009, Python 3.3)     Basically, implements the <code>yield from</code> operator, allowing to transfer the generation to another generator. If only <code>yield</code> as statement are used, this is equivalent to iterating over the subgenerator via a classical <code>for</code> loop, but if the <code>yield</code> is used as an expression (for instance in <code>x = yield</code>), meaning that the generator is actually a coroutine, then the <code>yield from</code> expression also transfer:</p> <ul> <li>the data sent by the <code>send()</code> command</li> <li>the errors sent by the <code>throw()</code> command</li> <li>the exception sent by the <code>close()</code> command</li> </ul> </li> <li> <p>PEP 492 -- Coroutines with async and await syntax (Python 3.5)</p> <ul> <li>09 Apr. 2015: Proposed</li> <li>05 May 2015: Accepted by Guido</li> <li>11 May 2015: Merged</li> </ul> </li> </ul>"},{"location":"programming/python/pep/#type-hints","title":"Type hints:","text":"<ul> <li>PEP 484 -- Type Hints (Python 3.5), by Guido. The most important one.</li> <li> <p>PEP 483 -- The Theory of Type Hints (Informational)   Lays down the theory of the previous one</p> </li> <li> <p>PEP 526 -- Syntax for Variable Annotations (Python 3.6, 09/08/2016):    Allow to annotate variables directly instead of inside comments.   Before: <pre><code>a = \"coucou\" # type: str\n</code></pre>   After: <pre><code>a: str = \"coucou\"\n</code></pre></p> </li> <li>PEP 585 -- Type Hinting Generics In Standard Collections (03/03/2019)   Abstract: \"Static typing as defined by PEPs 484, 526, 544, 560, and 563 was built incrementally on top of the existing Python runtime and constrained by existing syntax and runtime behavior. This led to the existence of a duplicated collection hierarchy in the typing module due to generics (for example typing.List and the built-in list).   This PEP proposes to enable support for the generics syntax in all standard collections currently available in the typing module.\"</li> </ul>"},{"location":"science/physics/","title":"Physics","text":""},{"location":"science/physics/#einstein","title":"Einstein","text":"<p>De l'\u00e9lectrodynamique des corps en mouvement</p>"}]}